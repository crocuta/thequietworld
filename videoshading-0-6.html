<!DOCTYPE html>
<html>
<head>

	<script type="text/javascript" src="webgl-utils.js"></script>
	<script type="text/javascript" src="glMatrix-0.9.5.min.js"></script>

	<script type="text/javascript" src="http://code.jquery.com/jquery.min.js"></script>
	<script src="/socket.io/socket.io.js"></script>
	<script src="scripts-qw.js"></script>


<title>WebGL Shader Lab</title>


<script id="shader-vs" type="x-shader/x-vertex"> 
  attribute vec3 aPos;
  attribute vec2 aTexCoord;
  varying   vec2 pixel;
void main(void) {
   gl_Position = vec4(aPos, 1.);
   pixel = aTexCoord;
}
</script>

<script id="shader-fs-blur-horizontal" type="x-shader/x-fragment">
#ifdef GL_ES
precision highp float;
#endif
// original shader from http://www.gamerendering.com/2008/10/11/gaussian-blur-filter-shader/
// horizontal blur fragment shader
uniform sampler2D src_tex;
varying vec2 pixel;
uniform vec2 pixelSize;
void main(void) // fragment
{
	float h = pixelSize.x;
	vec4 sum = vec4(0.0);
	sum += texture2D(src_tex, vec2(pixel.x - 4.0*h, pixel.y) ) * 0.05;
	sum += texture2D(src_tex, vec2(pixel.x - 3.0*h, pixel.y) ) * 0.09;
	sum += texture2D(src_tex, vec2(pixel.x - 2.0*h, pixel.y) ) * 0.12;
	sum += texture2D(src_tex, vec2(pixel.x - 1.0*h, pixel.y) ) * 0.15;
	sum += texture2D(src_tex, vec2(pixel.x + 0.0*h, pixel.y) ) * 0.16;
	sum += texture2D(src_tex, vec2(pixel.x + 1.0*h, pixel.y) ) * 0.15;
	sum += texture2D(src_tex, vec2(pixel.x + 2.0*h, pixel.y) ) * 0.12;
	sum += texture2D(src_tex, vec2(pixel.x + 3.0*h, pixel.y) ) * 0.09;
	sum += texture2D(src_tex, vec2(pixel.x + 4.0*h, pixel.y) ) * 0.05;
    gl_FragColor.xyz = sum.xyz/0.98; // normalize
	gl_FragColor.a = 1.;
} 
</script>

<script id="shader-fs-blur-vertical" type="x-shader/x-fragment">
#ifdef GL_ES
precision highp float;
#endif
// original shader from http://www.gamerendering.com/2008/10/11/gaussian-blur-filter-shader/
// vertical blur fragment shader
uniform sampler2D src_tex;
varying vec2 pixel;
uniform vec2 pixelSize;
void main(void) // fragment
{
	float v = pixelSize.y;
	vec4 sum = vec4(0.0);
	sum += texture2D(src_tex, vec2(pixel.x, - 4.0*v + pixel.y) ) * 0.05;
	sum += texture2D(src_tex, vec2(pixel.x, - 3.0*v + pixel.y) ) * 0.09;
	sum += texture2D(src_tex, vec2(pixel.x, - 2.0*v + pixel.y) ) * 0.12;
	sum += texture2D(src_tex, vec2(pixel.x, - 1.0*v + pixel.y) ) * 0.15;
	sum += texture2D(src_tex, vec2(pixel.x, + 0.0*v + pixel.y) ) * 0.16;
	sum += texture2D(src_tex, vec2(pixel.x, + 1.0*v + pixel.y) ) * 0.15;
	sum += texture2D(src_tex, vec2(pixel.x, + 2.0*v + pixel.y) ) * 0.12;
	sum += texture2D(src_tex, vec2(pixel.x, + 3.0*v + pixel.y) ) * 0.09;
	sum += texture2D(src_tex, vec2(pixel.x, + 4.0*v + pixel.y) ) * 0.05;
    gl_FragColor.xyz = sum.xyz/0.98;
	gl_FragColor.a = 1.;
}
</script>

<script id="shader-fs-advance" type="x-shader/x-fragment"> 
#ifdef GL_ES
precision highp float;
#endif

	uniform sampler2D sampler_prev;
	uniform sampler2D sampler_prev_n;
	uniform sampler2D sampler_blur;
	uniform sampler2D sampler_noise;
	uniform sampler2D sampler_noise_n;

	varying vec2 pixel;
	uniform vec2 pixelSize;
	uniform vec4 rnd;
	uniform vec2 mouse;
	uniform float time;
	uniform float fps;

void main(void) {

	// ==== Sans doute ici qu'il faudrait mettre des variables d'ajustement..  dans les facteurs du blur (optimum entre 0.5 et 1.3)
	// vc2(2,0) & vec2(0,2) super intéressant pour la rythmique
	
	// grabbing the blurred gradients
	vec2 d = pixelSize*1.;
	vec4 dx = (texture2D(sampler_blur, pixel + vec2(9,0)*d) - texture2D(sampler_blur, pixel - vec2(9,0)*d))*0.8;
	vec4 dy = (texture2D(sampler_blur, pixel + vec2(0,9)*d) - texture2D(sampler_blur, pixel - vec2(0,9)*d))*0.8;
	
	vec2 zoom_in = pixel + vec2(dx.x,dy.x)*pixelSize*5.; // adding the traveling wave front
	vec2 rand_noise = texture2D(sampler_noise, zoom_in + vec2(rnd.x, rnd.y)).xy;
	gl_FragColor.x = texture2D(sampler_prev, zoom_in).x + (rand_noise.x-0.5)*0.1 - 0.002; // decay with error diffusion
	gl_FragColor.x -= (texture2D(sampler_blur, zoom_in + (rand_noise-0.5)*pixelSize).x -
					  texture2D(sampler_prev, zoom_in + (rand_noise-0.1)*pixelSize)).x*0.9; // reaction-diffusion > ON PEUT FAIRE VARIER LES PARAMETRES DU BRUIT :-)

	gl_FragColor.a = 1.;
}
</script>

<script id="shader-fs-composite" type="x-shader/x-fragment">
#ifdef GL_ES
precision highp float;
#endif

        uniform sampler2D sampler_prev;
        uniform sampler2D sampler_prev_n;
        uniform sampler2D sampler_blur;
        uniform sampler2D sampler_noise;
        uniform sampler2D sampler_noise_n;

        varying vec2 pixel;
        uniform vec2 pixelSize;
        uniform vec2 aspect;
        uniform vec4 rnd;
        uniform vec2 mouse;
        uniform float time;



void main(void) {

vec4   luma = vec4(0.299, 0.587, 0.114,1.0);

// grabbing the blurred gradients
vec2 d = pixelSize*2.;
vec4 dx = (texture2D(sampler_blur, pixel + vec2(0.1,0)*d) - texture2D(sampler_blur, pixel - vec2(0.1,0)*d))*0.1;
vec4 dy = (texture2D(sampler_blur, pixel + vec2(0,0.1)*d) - texture2D(sampler_blur, pixel - vec2(0,0.1)*d))*0.1;
vec4 rd = vec4(texture2D(sampler_prev,pixel+vec2(dx.x,dy.x)*pixelSize*8.).x)*vec4(0.7,1.5,2.0,1.0)-vec4(0.3,1.0,1.0,1.0);
vec4  pict = texture2D(sampler_prev_n, pixel);
float col  = dot(luma,rd);	
float bw  =  (-1.0+1.0*dot(luma,pict));

	if (col + bw > 0.0) col = 1.0;
	if (col - bw > 0.0) col = 1.0;
	else col = 0.0;

gl_FragColor = col*vec4(1.0,1.0,1.0,1.0);
}
        </script>


	<script type="text/javascript" src="https://ajax.googleapis.com/ajax/libs/jquery/1.6.1/jquery.min.js"></script>
	
	<script type="text/javascript">

	function getShader(gl, id) {
		var shaderScript = document.getElementById(id);
		var str = "";
		var k = shaderScript.firstChild;
		while (k) {
			if (k.nodeType == 3)
				str += k.textContent;
			k = k.nextSibling;
		}
		var shader;
		if (shaderScript.type == "x-shader/x-fragment")
			shader = gl.createShader(gl.FRAGMENT_SHADER);
		else if (shaderScript.type == "x-shader/x-vertex")
			shader = gl.createShader(gl.VERTEX_SHADER);
		else
			return null;
		gl.shaderSource(shader, str);
		gl.compileShader(shader);
		if (gl.getShaderParameter(shader, gl.COMPILE_STATUS) == 0)
			alert(gl.getShaderInfoLog(shader));
		return shader;
	}

	requestAnimFrame = (function() {
		return window.webkitRequestAnimationFrame || window.mozRequestAnimationFrame || function(callback, element) {
			setTimeout(callback, 1000 / 60);
		};
	})();

	var gl;
	var prog_advance;
	var prog_composite;
	var prog_blur_horizontal;
	var prog_blur_vertical;
	var FBO_main;
	var FBO_main2;
	var FBO_helper;
	var FBO_blur;
	var FBO_noise;
	var texture_main_l; // main, linear
	var texture_main_n; // main, nearest (accurate pixel access on the same buffer)
	var texture_main2_l; // main double buffer, linear
	var texture_main2_n; // main double buffer, nearest (accurate pixel access on the same buffer)
	var texture_helper; // to be used when a buffer for multi-pass shader programs is needed (2-pass Gaussian blur)
	var texture_blur; // blur result
	var texture_noise_n; // noise pixel accurate
	var texture_noise_l; // noise interpolated pixel access

	var halted = false;
	var delay = 30; // possible de modifier? Il faudrait trouver un paramètre de réactivité
	var it = 1;
	var frames = 50;
	var fps = 30; // no hurdle for DX10 graphics cards

	//==============VARIABLES CAPTEURS

	var mySize  = 513; // Set initial size
	var mySpeed = 0;
	var myRand  = -25;
	var time;
	var mouseX = 0.5;
	var mouseY = 0.5;
	var animation;
	var timer;
	// texture size (must be powers of two, remember 2048x512 flat could also be a 128x128x128 voxel)
	var sizeX = 1024;
	var sizeY = 1024; // 2048x512 flat or 128x128x128 cube
	// viewport size
	var viewX = 1024;
	var viewY = 1024;

	var videoElement;

	function load() {
		clearInterval(timer);
		var canvas = document.getElementById("canvas");

		videoElement = document.getElementById("video");
		videoElement.crossOrigin = "anonymous";


		    videoElement.addEventListener("canplaythrough", startVideo, true);
		    videoElement.addEventListener("ended", videoDone, true);



		try {
			gl = canvas.getContext("experimental-webgl", { depth : false });
		} catch (e) {
		}
		if (!gl) {
			alert("Your browser does not support WebGL");
			return;
		}
		document.onmousemove = function(evt) {
			mouseX = evt.pageX / viewX;
			mouseY = 1 - evt.pageY / viewY;
		};

		canvas.width = viewX;
		canvas.height = viewY;

		function drawScene() {

		prog_advance = gl.createProgram();
		gl.attachShader(prog_advance, getShader(gl, "shader-vs"));
		gl.attachShader(prog_advance, getShader(gl, "shader-fs-advance"));
		gl.linkProgram(prog_advance);

		prog_composite = gl.createProgram();
		gl.attachShader(prog_composite, getShader(gl, "shader-vs"));
		gl.attachShader(prog_composite, getShader(gl, "shader-fs-composite"));
		gl.linkProgram(prog_composite);

		prog_blur_horizontal = gl.createProgram();
		gl.attachShader(prog_blur_horizontal, getShader(gl, "shader-vs"));
		gl.attachShader(prog_blur_horizontal, getShader(gl, "shader-fs-blur-horizontal"));
		gl.linkProgram(prog_blur_horizontal);

		prog_blur_vertical = gl.createProgram();
		gl.attachShader(prog_blur_vertical, getShader(gl, "shader-vs"));
		gl.attachShader(prog_blur_vertical, getShader(gl, "shader-fs-blur-vertical"));
		gl.linkProgram(prog_blur_vertical);

		var posBuffer = gl.createBuffer();
		gl.bindBuffer(gl.ARRAY_BUFFER, posBuffer);

		var vertices = new Float32Array([ -1, -1, 0, 1, -1, 0, -1, 1, 0, 1, 1, 0 ]);

		var aPosLoc = gl.getAttribLocation(prog_advance, "aPos");
		gl.enableVertexAttribArray(aPosLoc);

		var aTexLoc = gl.getAttribLocation(prog_advance, "aTexCoord");
		gl.enableVertexAttribArray(aTexLoc);

		var texCoords = new Float32Array([ 0, 0, 1, 0, 0, 1, 1, 1 ]);

		var texCoordOffset = vertices.byteLength;

		gl.bufferData(gl.ARRAY_BUFFER, texCoordOffset + texCoords.byteLength, gl.STATIC_DRAW);
		gl.bufferSubData(gl.ARRAY_BUFFER, 0, vertices);
		gl.bufferSubData(gl.ARRAY_BUFFER, texCoordOffset, texCoords);
		gl.vertexAttribPointer(aPosLoc, 3, gl.FLOAT, gl.FALSE, 0, 0);
		gl.vertexAttribPointer(aTexLoc, 2, gl.FLOAT, gl.FALSE, 0, texCoordOffset);

		var noisepixels = [];
		var pixels = [];
		for ( var i = 0; i < sizeX; i++) {
			for ( var j = 0; j < sizeY; j++) {
				noisepixels.push(Math.random() * 255, Math.random() * 255, Math.random() * 255, 255);
				pixels.push(0, 0, 0, 255);
			}
		}
		/*
		 * if (Math.random() > density) pixels.push(0, 0, 0, 0); else pixels.push(255, 0, 0, 0);
		 */

		var previousTime=0;

		var rawData = new Uint8Array(noisepixels);
		texture_main_l = gl.createTexture();
		gl.bindTexture(gl.TEXTURE_2D, texture_main_l);
		gl.pixelStorei(gl.UNPACK_ALIGNMENT, 1);
		gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, sizeX, sizeY, 0, gl.RGBA, gl.UNSIGNED_BYTE, rawData);
		gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);
		gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);

		texture_main_n = gl.createTexture();
		gl.bindTexture(gl.TEXTURE_2D, texture_main_n);
		gl.pixelStorei(gl.UNPACK_ALIGNMENT, 1);
		gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, sizeX, sizeY, 0, gl.RGBA, gl.UNSIGNED_BYTE, rawData);
		gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST);
		gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST);

		rawData = new Uint8Array(noisepixels);
		rawData = new Uint8Array(noisepixels);
		texture_main2_l = gl.createTexture();
		gl.bindTexture(gl.TEXTURE_2D, texture_main2_l);
		gl.pixelStorei(gl.UNPACK_ALIGNMENT, 1);
		gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, sizeX, sizeY, 0, gl.RGBA, gl.UNSIGNED_BYTE, rawData);
		gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);
		gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);

		texture_main2_n = gl.createTexture();
		gl.bindTexture(gl.TEXTURE_2D, texture_main2_n);
		gl.pixelStorei(gl.UNPACK_ALIGNMENT, 1);
		gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, sizeX, sizeY, 0, gl.RGBA, gl.UNSIGNED_BYTE, rawData);
		gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST);
		gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST);

		rawData = new Uint8Array(pixels);
		texture_helper = gl.createTexture();
		gl.bindTexture(gl.TEXTURE_2D, texture_helper);
		gl.pixelStorei(gl.UNPACK_ALIGNMENT, 1);
		gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, sizeX, sizeY, 0, gl.RGBA, gl.UNSIGNED_BYTE, rawData);
		gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);
		gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);

		rawData = new Uint8Array(pixels);
		texture_blur = gl.createTexture();
		gl.bindTexture(gl.TEXTURE_2D, texture_blur);
		gl.pixelStorei(gl.UNPACK_ALIGNMENT, 1);
		gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, sizeX, sizeY, 0, gl.RGBA, gl.UNSIGNED_BYTE, rawData);
		gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);
		gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);

		rawData = new Uint8Array(noisepixels);
		texture_noise_l = gl.createTexture();
		gl.bindTexture(gl.TEXTURE_2D, texture_noise_l);
		gl.pixelStorei(gl.UNPACK_ALIGNMENT, 1);
		gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, sizeX, sizeY, 0, gl.RGBA, gl.UNSIGNED_BYTE, rawData);
		gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);
		gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);

		texture_noise_n = gl.createTexture();
		gl.bindTexture(gl.TEXTURE_2D, texture_noise_n);
		gl.pixelStorei(gl.UNPACK_ALIGNMENT, 1);
		gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, sizeX, sizeY, 0, gl.RGBA, gl.UNSIGNED_BYTE, rawData);
		gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST);
		gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST);

	  

		// gl.uniform1i(gl.getUniformLocation(prog, "uTexSamp"), 0);
		FBO_main = gl.createFramebuffer();
		gl.bindFramebuffer(gl.FRAMEBUFFER, FBO_main);
		gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, texture_main_l, 0);

		FBO_main2 = gl.createFramebuffer();
		gl.bindFramebuffer(gl.FRAMEBUFFER, FBO_main2);
		gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, texture_main2_l, 0);

		FBO_helper = gl.createFramebuffer();
		gl.bindFramebuffer(gl.FRAMEBUFFER, FBO_helper);
		gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, texture_helper, 0);

		FBO_blur = gl.createFramebuffer();
		gl.bindFramebuffer(gl.FRAMEBUFFER, FBO_blur);
		gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, texture_blur, 0);

		FBO_noise = gl.createFramebuffer();
		gl.bindFramebuffer(gl.FRAMEBUFFER, FBO_noise);
		gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, texture_noise_l, 0);

		gl.useProgram(prog_advance);
		setUniforms(prog_advance);

		gl.useProgram(prog_blur_horizontal);
		gl.uniform2f(gl.getUniformLocation(prog_blur_horizontal, "pixelSize"), 1. / sizeX, 1. / sizeY);
		gl.uniform1i(gl.getUniformLocation(prog_blur_horizontal, "src_tex"), 0);

		gl.useProgram(prog_blur_vertical);
		gl.uniform2f(gl.getUniformLocation(prog_blur_vertical, "pixelSize"), 1. / sizeX, 1. / sizeY);
		gl.uniform1i(gl.getUniformLocation(prog_blur_vertical, "src_tex"), 0);

		gl.useProgram(prog_composite);
		setUniforms(prog_composite);

		gl.activeTexture(gl.TEXTURE2);
		gl.bindTexture(gl.TEXTURE_2D, texture_blur);

		gl.activeTexture(gl.TEXTURE3);
		gl.bindTexture(gl.TEXTURE_2D, texture_noise_l);

		gl.activeTexture(gl.TEXTURE4);
		gl.bindTexture(gl.TEXTURE_2D, texture_noise_n);

		calculateBlurTexture();
		}

		drawScene();

		initTexture();

    	updateTexture();


		timer = setInterval(fr, 500);
		time = new Date().getTime();
		animation = "animate";
		anim();
	}


  var my_texture;

  function initTexture() {
  my_texture = gl.createTexture();
  gl.bindTexture(gl.TEXTURE_2D, my_texture);
  gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, true);

  gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);
  gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);

  gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
  gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);

  gl.bindTexture(gl.TEXTURE_2D, null);
}


  function startVideo() {
  videoElement.play();
  intervalID = setInterval(drawScene, 15);
}

function videoDone() {
  clearInterval(intervalID);
}


function handleLoadedTexture(texture) {
    gl.bindTexture(gl.TEXTURE_2D, texture);
    gl.pixelStore(gl.UNPACK_FLIP_Y_WEBGL, true);
    gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, texture.image);
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST);
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST);
    
  }

  function updateTexture() {
  gl.bindTexture(gl.TEXTURE_2D, my_texture);
  gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, videoElement);



}

	function setUniforms(program) {
		
		gl.uniform2f(gl.getUniformLocation(program, "pixelSize"), 1.0*mySize / sizeX,1.0*mySize/ sizeY);
		gl.uniform4f(gl.getUniformLocation(program, "rnd"), myRand*Math.random(), myRand*Math.random(), myRand*Math.random(), myRand*Math.random());
		gl.uniform1f(gl.getUniformLocation(program, "delay"), delay*mySpeed);
		gl.uniform1f(gl.getUniformLocation(program, "time"), time*mySpeed);
		gl.uniform2f(gl.getUniformLocation(program, "aspect"), Math.max(1, viewX / viewY), Math.max(1, viewY / viewX));
		gl.uniform2f(gl.getUniformLocation(program, "mouse"), mouseX, mouseY);
		gl.uniform1i(gl.getUniformLocation(program, "sampler_prev"), 0);
		gl.uniform1i(gl.getUniformLocation(program, "sampler_prev_n"), 1);
		gl.uniform1i(gl.getUniformLocation(program, "sampler_blur"), 2);
		gl.uniform1i(gl.getUniformLocation(program, "sampler_noise"), 3);
		gl.uniform1i(gl.getUniformLocation(program, "sampler_noise_n"), 4);
	}
	function calculateBlurTexture() {
		// horizontal
		gl.viewport(0, 0, sizeX, sizeY);
		gl.useProgram(prog_blur_horizontal);
		gl.activeTexture(gl.TEXTURE0);
		if (it < 0) {
			gl.bindTexture(gl.TEXTURE_2D, texture_main2_l);
			gl.bindFramebuffer(gl.FRAMEBUFFER, FBO_helper);
		} else {
			gl.bindTexture(gl.TEXTURE_2D, texture_main_l);
			gl.bindFramebuffer(gl.FRAMEBUFFER, FBO_helper);
		}
		gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4);
		gl.flush();

		// vertical
		gl.viewport(0, 0, sizeX, sizeY);
		gl.useProgram(prog_blur_vertical);
		gl.activeTexture(gl.TEXTURE0);
		gl.bindTexture(gl.TEXTURE_2D, texture_helper);
		gl.bindFramebuffer(gl.FRAMEBUFFER, FBO_blur);
		gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4);
		gl.flush();

		gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4);
		gl.flush();
	}

	function advance() {
		gl.viewport(0, 0, sizeX, sizeY);
		gl.useProgram(prog_advance);
		setUniforms(prog_advance);
		if (it > 0) {
			gl.activeTexture(gl.TEXTURE0);
			gl.bindTexture(gl.TEXTURE_2D, texture_main_l); // interpolated input
			gl.activeTexture(gl.TEXTURE1);
			gl.bindTexture(gl.TEXTURE_2D, texture_main_n); // "nearest" input
			gl.bindFramebuffer(gl.FRAMEBUFFER, FBO_main2); // write to buffer
		} else {
			gl.activeTexture(gl.TEXTURE0);
			gl.bindTexture(gl.TEXTURE_2D, texture_main2_l); // interpolated
			gl.activeTexture(gl.TEXTURE1);
			gl.bindTexture(gl.TEXTURE_2D, texture_main2_n); // "nearest"
			gl.bindFramebuffer(gl.FRAMEBUFFER, FBO_main); // write to buffer
		}
		gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4);
		gl.flush();

		calculateBlurTexture();
		it = -it;
	}

	function composite() {
		gl.viewport(0, 0, viewX, viewY);
		gl.useProgram(prog_composite);
		setUniforms(prog_composite);
		if (it < 0) {
			gl.activeTexture(gl.TEXTURE0);
			gl.bindTexture(gl.TEXTURE_2D, texture_main_l);
			gl.activeTexture(gl.TEXTURE1);
			gl.bindTexture(gl.TEXTURE_2D, my_texture);
		} else {
			gl.activeTexture(gl.TEXTURE0);
			gl.bindTexture(gl.TEXTURE_2D, texture_main2_l);
			gl.activeTexture(gl.TEXTURE1);
			gl.bindTexture(gl.TEXTURE_2D, my_texture);
		}
		gl.bindFramebuffer(gl.FRAMEBUFFER, null);
		gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4);
		gl.flush();
		frames++;
	}

	function anim() {
		if (!halted)
			advance();
		composite();
		switch (animation) {
		case "animate":
			setTimeout("requestAnimFrame(anim)", delay);
			break;
		case "reset":
			load();
			break;
		}
	}
	function setDelay(v) {
		delay = parseInt(v);
	}
	function fr() {
		var ti = new Date().getTime();
		fps = Math.round(1000 * frames / (ti - time));
		document.getElementById("fps").textContent = fps;
		frames = 0;
		time = ti;
	}
	
		$(function(){
			
			$("#champ1").after('<output1></output1>');
			$("#champ1").live('change', function(){
				var valof = $(this).val();
				$('output1').text(valof);
				mySize = valof;
				console.log(mySize);
			});
			$("#champ2").after('<output2></output2>');
			$("#champ2").live('change', function(){
				var valof = $(this).val();
				$('output2').text(valof);
				mySpeed = valof;
				console.log(mySpeed);
			});
			$("#champ3").after('<output3></output3>');
			$("#champ3").live('change', function(){
				var valof = $(this).val();
				$('output3').text(valof);
				myRand = valof;
				console.log(myRand);
			});

			$("#champ4").after('<output4></output4>');
			$("#champ4").live('change', function(){
				var valof = $(this).val();
				$('output4').text(valof);
				myLum = valof;
				console.log(myLum);
			});
		});
	</script>
		
<style type="text/css">
body {
	background-color: #000000;
	color: #FFFFFF;
	text-shadow: #000000;
}

#canvas {
	position: absolute;
	top: 0;
	left: 0;
	z-index: -1;
}
</style>
</head>
<body onload="load()">
	<br />Size
	<!-- À PROPOS DE LA TAILLE
		LE PARAMETRE "SIZE" a pour propriété de faire varier l'amplitude des ondes qui courent jusqu'au bord de l'image. Ainsi, il y a quelques effets de "nombres magiques" L'image est extrêmemnt peu lisible avant le size 200, a des effets de vagues et de clignotement entre 200 et 400, est optimale vers 410 - 510 et redevient illisible, trop blanche, après 515.

		COMPLETEMENT STABLE A 509

		510: effet peau d'orange

		 !-->
	<form action="slider-control.php" method="post">
		<input type="range" id="champ1" name="range" min="400" max="600" step="0.1" name="rating" />
	</form>
	<br />Speed
	<form action="slider-control.php" method="post">
		<input type="range" id="champ2" name="range" min="0" max="10" step="0.1" name="rating" />
	</form>
	<br />Rand
	<form action="slider-control.php" method="post">
		<input type="range" id="champ3" name="range" min="0" max="10" step="0.1" name="rating" />
	</form>
	<br />Luminance Threshold
	<form action="slider-control.php" method="post">
		<input type="range" id="champ4" name="range" min="0.1" max="0.9" step="0.1" name="rating" />
	</form>
	Fps:
	<span id="fps">58</span>

	<canvas height="512" width="512" id="canvas">
	</canvas>

	<video id="video" src="video.ogv" autoplay crossorigin = "anonymous" style ="display:none";
></video>


</p></body></html>
